<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE section PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
<!ENTITY % common_entities SYSTEM "../../../common.ent">
%common_entities;
]>

<section id="authorization-secrets-lecture"><title>Managing Sensitive Information with Secrets</title>
  <section>
    <title>Objectives</title>
    <para>
      After completing this section, you should be able to:
    </para>
    <itemizedlist>
      <listitem>
        <para>
          Create and apply secrets to manage sensitive information.
        </para>
      </listitem>
      <listitem>
        <para>
          Share secrets between applications.
        </para>
      </listitem>
    </itemizedlist>
  </section>

  <section>
    <title>Secrets Overview</title>
    <para>
      Modern applications are designed to loosely couple code, configuration, and data.
      Configuration files and data are not hard-coded as part of the software.
      Instead, the software loads configuration and data from an external source.
      This enables deploying an application to different environments without requiring a change to the application source code.
    </para>
    <para>
      Often applications require access to sensitive information.
      As an example, a back-end web application requires access to database credentials to perform a database query.
    </para>
    <para>
      Kubernetes and OpenShift use secret resources to hold sensitive information, such as:
    </para>
    <itemizedlist spacing="compact">
      <listitem>
        <para>
          Passwords.
        </para>
      </listitem>
      <listitem>
        <para>
          Sensitive configuration files.
        </para>
      </listitem>
      <listitem>
        <para>
          Credentials to an external resource, such as an SSH key or OAuth token.
        </para>
      </listitem>
    </itemizedlist>
    <para>
      A secret can store any type of data.
      Data in a secret is Base64-encoded, so it is not stored in plain text.
      Secret data is not encrypted; you can decode the secret from Base64 format to access the original data.
    </para>
    <para>
      Although secrets can store any type of data, Kubernetes and OpenShift support different types of secrets.
      Different types of secret resources exist, including service account tokens, SSH keys, and TLS certificates.
      When you store information in a specific secret resource type, Kubernetes validates that the data conforms to the type of secret.
    </para>

    <section>
      <title>Features of Secrets</title>
      <para>
        The main features of secrets include:
      </para>
      <itemizedlist>
        <listitem>
          <para>
            Secret data can be shared within a project namespace.
          </para>
        </listitem>
        <listitem>
          <para>
            Secret data is referenced independently of secret definition.
            Administrators can create and manage a secret resource, and other team members reference the secret in their deployment configurations.
          </para>
        </listitem>
        <listitem>
          <para>
            Secret data is injected into pods when OpenShift creates a pod.
            You can expose a secret as an environment variable or as a mounted file in the pod.
          </para>
        </listitem>
        <listitem>
          <para>
            If the value of a secret changes during pod execution, the secret data does not update in the pod.
            After a secret value changes, you must create new pods to inject the new secret data.
          </para>
        </listitem>
        <listitem>
           <para>
             Any secret data that OpenShift injects into a pod is ephemeral.
             If OpenShift exposes sensitive data to a pod as environment variables, those variables are destroyed when the pod is destroyed.
           </para>
           <para>
             If a secret is mounted as a file in the pod, the file is also destroyed when the pod is destroyed.
             Secret data volumes are backed by temporary file storage.
           </para>
        </listitem>
      </itemizedlist>
    </section>

  </section>


  <section>
    <title>Use Cases for Secrets</title>
    <para>
      Two primary use cases for secrets are storing credentials and securing communication between services. These are discussed below.
    </para>
    <section>
      <title>Credentials</title>
      <para>
        Store sensitive information, such as passwords and user names, in a secret.
      </para>
      <para>
        If an application expects to read sensitive information from a file, then you mount the secret as a data volume to the pod.
        The application can read the secret as an ordinary file to access the sensitive information.
        Some databases, for example, read credentials from a file to authenticate users.
      </para>
      <para>
        Some applications use environment variables to read configuration and sensitive data.
        You can link secret variables to pod environment variables in a deployment configuration.
      </para>
    </section>
    <section>
      <title>Transport Layer Security (TLS) and Key Pairs</title>
      <para>
        You can secure communication to a service by having the cluster generate a signed certificate and key pair into a secret within the project namespace.
        The certificate and key pair are stored using PEM format, in files such as <code>tls.crt</code> and <code>tls.key</code>, located in the secret's data volume of the pod.
      </para>
    </section>
  </section>

  <section>
    <title>Creating a Secret</title>
      <para>
        If a pod requires access to sensitive information, then create a secret for the information before you deploy the pod.
      </para>
      <itemizedlist>
        <listitem>
          <para>
            Create a generic secret using key/value pairs using literal values typed on the command line:
          </para>
<screen><prompt>[user@demo ~]$ </prompt><userinput>oc create secret generic <replaceable>secret_name</replaceable> \</userinput>
<prompt>&gt; </prompt>   <userinput>--from-literal key1=<replaceable>secret1</replaceable> \</userinput>
<prompt>&gt; </prompt>   <userinput>--from-literal key2=<replaceable>secret2</replaceable></userinput></screen>
        </listitem>
        <listitem>
          <para>
            Create a generic secret using key names specified on the command line and values from files:
          </para>
<screen><prompt>[user@demo ~]$ </prompt><userinput>oc create secret generic <replaceable>ssh-keys</replaceable> \</userinput>
<prompt>&gt; </prompt>   <userinput>--from-file <replaceable>id_rsa=/path-to/id_rsa</replaceable> \</userinput>
<prompt>&gt; </prompt>   <userinput>--from-file <replaceable>id_rsa.pub=/path-to/id_rsa.pub</replaceable></userinput></screen>
        </listitem>
        <listitem>
        <para>
          Create a TLS secret specifying a certificate and the associated key:
        </para>
<screen><prompt>[user@demo ~]$ </prompt><userinput>oc create secret tls <replaceable>secret-tls</replaceable> \</userinput>
<prompt>&gt; </prompt>   <userinput>--cert <replaceable>/path-to-certificate</replaceable> --key <replaceable>/path-to-key</replaceable></userinput></screen>
      </listitem>
    </itemizedlist>

  </section>

  <section>
    <title>Exposing Secrets to Pods</title>
    <para>
      To expose a secret to a pod, first create the secret.
      Assign each piece of sensitive data to a key.
      After creation, the secret contains key-value pairs.
    </para>
    <para>
      The following command creates a generic secret named <code>demo-secret</code> with two keys: <code>user</code> with the <code>demo-user</code> value and <code>root_password</code> with the <code>zT1KTgk</code> value.
    </para>
<screen><prompt>[user@demo ~]$ </prompt><userinput>oc create secret generic <replaceable>demo-secret</replaceable> \</userinput>
<prompt>&gt; </prompt>   <userinput>--from-literal <code>user</code>=demo-user</userinput>
<prompt>&gt; </prompt>   <userinput>--from-literal <code>root_password</code>=zT1KTgk</userinput> </screen>
    <section>
      <title>Secrets as Pod Environment Variables</title>
      <para>
        Consider a database application that reads the database administrator password from the <code>MYSQL_ROOT_PASSWORD</code> environment variable.
        Modify the environment variables section of the deployment configuration to use values from the secret:
      </para>
<screen>env:
  - name: MYSQL_ROOT_PASSWORD <co id="authorization-secrets-env-name"/>
    valueFrom:
      secretKeyRef:
        name: <code>demo-secret</code> <co id="authorization-secret-name"/>
        key: <code>root_password</code> <co id="authorization-secrets-key-name"/></screen>
      <calloutlist>
        <callout arearefs="authorization-secrets-env-name">
          <para>
            The environment variable name in the pod, which contains data from a secret.
          </para>
        </callout>
        <callout arearefs="authorization-secret-name">
          <para>
            The name of the secret that contains the desired sensitive information.
          </para>
        </callout>
        <callout arearefs="authorization-secrets-key-name">
          <para>
            The name of the key that contains the sensitive information in the secret.
          </para>
        </callout>
      </calloutlist>
      <para>
        You can also use the <code>oc set env</code> command to set application environment variables from secret values.
        In some cases, the names of the keys can be modified to match the names of envrionmental variables by using the <code>--prefix</code> option.
        In the example below, the <code>user</code> key sets the <code>MYSQL_USER</code> environmental variable, and the <code>root_password</code> key sets the <code>MYSQL_ROOT_PASSWORD</code> environmental variable.
        If the key name is lowercase, then the corresponding environment variable is converted to uppercase.
      </para>
<screen><prompt>[user@demo ~]$ </prompt><userinput>oc set env <replaceable>deployment/demo</replaceable> --from <replaceable>secret/demo-secret</replaceable> \</userinput>
<prompt>&gt; </prompt>   <userinput>--prefix MYSQL_</userinput></screen>
    </section>

    <section>
      <title>Secrets as Files in a Pod</title>
      <para>
        A secret can be mounted to a directory within a pod.
        A file is created for each key in the secret using the name of the key.
        The content of each file is the decoded value of the secret.
      </para>
<screen><prompt>[user@demo ~]$ </prompt><userinput>oc set volume <replaceable>deployment/demo</replaceable> <co id="authorization-secrets-vol-dc-name"/> \</userinput>
<prompt>&gt; </prompt>   <userinput>--add --type secret <co id="authorization-secrets-vol-add"/> \</userinput>
<prompt>&gt; </prompt>   <userinput>--secret-name <replaceable>demo-secret</replaceable> <co id="authorization-secrets-vol-secret-name"/> \</userinput>
<prompt>&gt; </prompt>   <userinput>--mount-path <replaceable>/app-secrets</replaceable> <co id="authorization-secrets-vol-mount-path"/></userinput></screen>
      <calloutlist>
        <callout arearefs="authorization-secrets-vol-dc-name">
          <para>
            Modify the volume configuration in the <code>demo</code> deployment.
          </para>
        </callout>
        <callout arearefs="authorization-secrets-vol-add">
          <para>
            Add a new volume from a secret.
          </para>
        </callout>
        <callout arearefs="authorization-secrets-vol-secret-name">
          <para>
            Use the <code>demo-secret</code> secret.
          </para>
        </callout>
        <callout arearefs="authorization-secrets-vol-mount-path">
          <para>
            Make the secret data available in the <code>/app-secrets</code> directory in the pod.
            The content of the <code>/app-secrets/user</code> file is <code>demo-user</code>.
            The content of the <code>/app-secrets/root_password</code> file is <code>zT1KTgk</code>.
          </para>
        </callout>
      </calloutlist>

      <para>
        The location of the mount point and the expected file names can be dictated by the container image.
        For example, a container image running <code>NGINX</code> can specify the SSL certificate location and the SSL certificate key location in the <code>/etc/nginx/nginx.conf</code> configuration file.
        If the expected files are not found, then the container might fail to run.
      </para>

      <important>
        <para>
          If the mount point already exists in the pod, then any existing files at the mount point are obscurred by the mounted secret.
          The existing files are not visible and are not accessible.
        </para>
      </important>
    </section>

  </section>

  <section>
    <title>Configuration Map Overview</title>
    <para>
      Similar to secrets, configuration maps decouple configuration information from container images.
      Unlike secrets, the information contained in configuration maps does not need to be protected.
      The data in a configuration map can be used to set environmental variables in the container image, or the configuration map can be mounted as a volume within the container image.
      Container images do not need to be rebuilt when a secret or a configuration map changes.
      New pods use the updated secrets and configuration maps.
      Pods using the older secrets and configuration maps can be deleted.
    </para>
    <para>
      The syntax for creating a configuration map closely matches the syntax for creating a secret.
      Key/value pairs can be entered on the command line or the content of a file can be used as the value of a specified key.
    </para>
    <screen><prompt>[user@demo ~]$ </prompt><userinput>oc create configmap <replaceable>my-config</replaceable> \</userinput>
<prompt>&gt; </prompt>   <userinput>--from-literal <replaceable>key1=config1</replaceable> --from-literal <replaceable>key2=config2</replaceable></userinput></screen>
  </section>

  <section>
    <title>Updating Secrets and Configuration Maps</title>
    <para>
      Secrets and configuration maps occasionally require updates.
      Use the <code>oc extract</code> command to ensure you have the latest data.
      Save the data to a specific directory using the <code>--to</code> option.
      Each key in the secret or configuration map creates a file with the same name as the key.
      The content of each file is the value of the associated key.
      If you run the <code>oc extract</code> command more than once, then use the <code>--confirm</code> option to overwrite the existing files.
    </para>
    <screen><prompt>[user@demo ~]$ </prompt><userinput>oc extract secret/<replaceable>htpasswd-ppklq</replaceable> \</userinput>
<prompt>&gt; </prompt>   <userinput>-n openshift-config --to /tmp/ --confirm</userinput>
/tmp/htpasswd</screen>
    <para>
      After updating the locally saved files, use the <code>oc set data</code> command to update the secret or configuration map.
      For each key that requires an update, specify the name of a key and the associated value.
      If a file contains the value, use the <code>--from-file</code> option.
    </para>
    <para>
      In the previous <code>oc extract</code> example, the <code>htpasswd-ppklq</code> secret contained only one key named <code>htpasswd</code>.
      Using the <code>oc set data</code> command, you can explicity specify the <code>htpasswd</code> key name using <code>--from-file htpasswd=/tmp/htpasswd</code>.
      If the key name is not specified, the file name is used as the key name.
    </para>
    <screen><prompt>[user@demo ~]$ </prompt><userinput>oc set data secret/<replaceable>htpasswd-ppklq</replaceable> -n openshift-config \</userinput>
<prompt>&gt; </prompt>   <userinput>--from-file /tmp/htpasswd</userinput>
secret/htpasswd-ppklq data updated</screen>
  </section>

  <section>
    <title>&nbsp;</title>
    <note role="References">
      <para>
        For more information on secrets, refer to the <citetitle>Understanding secrets</citetitle> section in the <citetitle>Working with pods</citetitle> chapter in the Red&nbsp;Hat OpenShift Container Platform&nbsp;4.5 <citetitle>Nodes</citetitle> documentation at <ulink url="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.5/html-single/nodes/index#nodes-pods-secrets-about_nodes-pods-secrets"/>
      </para>
    </note>
  </section>

</section>
